<div align="center">
   <h1> אופטימיזציה למציאת ערכים מינימליים לפונקציות מורכבות </h1>
   <img src="https://github.com/YardenBoumendil/EvolutionaryOptimization/assets/96023071/8835b591-8ce7-4e00-a5c7-5acbfba4d107)" width="70%" high="70%">
</div>
   <h2>אלגוריתמים אבולוציוניים</h2>
   <p>אלגוריתמים אבולוציוניים הם טכניקות לפתרון בעיות המבוססות על תהליכי האבולוציה בטבע. הם מדמים תהליכים של שינוי גנטי, רבייה והישרדות של הראויים ביותר על מנת למצוא פתרונות מתאימים לבעיות מורכבות. בדומה לאבולוציה הביולוגית, האלגוריתמים האבולוציוניים יוצרים אוכלוסייה של פתרונות פוטנציאליים, מבצעים מוטציות וצירופים חדשים של הפתרונות, ובוחרים את הפתרונות הטובים ביותר להמשך תהליך האופטימיזציה.</p>

   <h2>הבעיה שבאנו לפתור והקשר לאלגוריתמים אבולוציוניים</h2>
   <p>הבעיה שבאנו לפתור היא מציאת ערכים מיטביים עבור פונקציות מורכבות שאינן ניתנות לייצוג מתמטי ישיר. במקרים כאלה, שיטות אנליטיות רגילות עלולות להיות בלתי יעילות או אף בלתי אפשריות. לכן, חשבנו לנצל את היתרונות של אלגוריתמים אבולוציוניים, שיכולים לחפש באופן יעיל בחלל הפתרונות המורכב ולמצוא ערכים מיטביים גם עבור פונקציות שאינן ליניאריות או דיפרנציאליות. החיבור בין הבעיה למציאת ערכים מיטביים של פונקציות מורכבות לבין השיטה של אלגוריתמים אבולוציוניים, שמיועדת לחיפוש בחללי חיפוש גדולים ומורכבים, נראה לנו כמתאים ולכן החלטנו לנסות לשלב ביניהם.</p>

   <h2>מיקוד הבעיה</h2>
   <p>בחנו את הפתרון של אלגוריתם האבולוציוני עבור הבעיה הבאה: נתונות 4 פונקציות f1, f2, g1, g2 וקבוע c וצריך למצוא x1, x2 כך שהביטוי f1(x1) + f2(x2) יהיה מינימלי בהינתן האילוץ g1(x1) + g2(x2) &lt;= c. כשהפונקציות הנתונות יכולות להיות גם פונקציות שאינן ניתנות לייצוג בכתיב מתמטי.</p>

   <h2>תיאור פתרון באמצעות אלגוריתם אבולוציוני</h2>
   <h3>אתחול האלגוריתם</h3>
   <p>האוכלוסייה: בנויה ממספר פרטים, כל פרט מורכב מוקטור בגודל 2 שמייצג את המשתנים שעלינו למצוא – x1, x2.<br>
   פיטנס: עבור הבעיה שלנו ככל שהפיטנס נמוך יותר הוא אופטימלי יותר.</p>

   <h3>חישוב הפיטנס</h3>
   <p>בהינתן פרט באוכלוסייה (x1,x2):<br>
   <div align="center">
      <img width="524" alt="משוואה" src="https://github.com/YardenBoumendil/EvolutionaryOptimization/assets/96023071/2bba45db-96b8-4d3d-8b73-265652ad92a0">
   </div>    
   <p>ניתן להבחין כי "העונש" שניתן עבור חוסר עמידה בתנאי הוא גדול מאוד אבל, מכיוון שאין לנו מידע על הפונקציות (האם הן רציפות, ניתנות לייצוג בכתיב מתמטי וכו') – אין לנו יכולת להבטיח עונש גבוה מספיק כך שהאלגוריתם יחזיר פלט תקין.</p>

   <p>יצירת אוכלוסיה חדשה – קרוס אובר מיוטשן – כאן לכתוב את הערכים שהחלטנו עליהם בסוף<br>
      <b>
   דורות - 150<br>
   אוכלוסייה – 500<br>
   קרוס – 0.15<br>
   מיוט – 0.15</b></p>

   <p>בחנו את הפרמטרים האופטימלים עבור גודל אוכלוסיה, מספר דורות, מוטציה וקרוס אובר בניסויים שביצענו ונפרט עליהם בהמשך הדוח.</p>

   <h3>התוכנה</h3>
   <div dir="rtl">
   <p>Main – הרצת התוכנית, אתחול והרצת האלגוריתם בהינתן ארגומנט<br>
   EvaluatorMetaData – מחזיק את הפונקציות הרנדומיות שאנחנו מגרילים, את הקבוע c, את הגבולות שבהם נרצה לבחון את המשתנים שלנו ורביעיית הפרמטרים – אוכלוסיה, דורות, קרוס אובר והמיטושן שבחרנו. בנוסף, מחזיק מידע כגון האם המשתמש רוצה סטטיסטיקות, סט של פרמטרים לבדיקה עבור סטטיסטיקות.<br>
   Analytics – מייצר קובץ אאוטופ שמפרט את היטנס עבור כל אחד מהדורות, מציג את גרף ההתכנסות עבור הערכים שניתנו ומוצא את הערך המינמלי שעומד בתנאים בדרך ישירה. יוצג רק כאשר המשתשמ בוחר לראות סטטיסטיקות.<br>
   FitnessEvaluator -חישוב הפיטנס לפי הפונקציה שתוארה מעלה.</p>
   </div>

   <h2>ניסויים ותוצאות</h2>
   <p>ביצענו 20 ריצות כשבכל אחת מהם בחנו את התוצאות עבור 54 קומבינציות שונות של ערכים (מספר דורות, גודל אוכלוסייה, קורס, מיוט).<br>
   בסוף הריצות חישבנו את הדור הממוצע בו האלגוריתם התכנס וכדי לבחון את ההצלחה של שאר האוכלוסיות ובחירת הקרוס והמוטציה האופטימליים דירגנו את הפרמטרים.</p>

   <ul>
   	<li>הגדרנו מספר הצלחות – כמספר הפעמים שזוג פרמטרים (קרוס ומיוט) הצליח להגיע לערך המינימלי של הפונקציה עבור בהינתן זוג הפרמטרים (מספר דורות, גודל אוכלוסיה) לאורך 20 ריצות שביצענו. לדוגמא עבור זוג הפרמטרים (cross=0.15, mutation=0.15), בהינתן (gen=100, population=250) - מספר ההצלחות הוא 16.</li>
   </ul>
      <div align="center">
         <img alt="תמונה3" src="https://github.com/YardenBoumendil/EvolutionaryOptimization/assets/96023071/8e8bdc57-5bc6-4891-8cec-31c0bcd5ebe6">
      </div>
   <ul>
   	<li>חישבנו את מספר ההצלחות הממוצע עבור זוג פרמטרים (קרוס ומוטציה) – בכל פעם בהינתן קבוצת אוכלוסייה שונה: {250, 400, 500}, {400,500}, {400}, {500}</li>
   	<li>חישבנו ציון בדרך הבאה – מספר ממוצע של הצלחות/סך כל הריצות.</li>
   </ul>

   <p>כל הנתונים מצורפים בקובץ "ProjectData.xlsx" שמצורף לפרויקט.</p>

   <h3>אוכלוסיות לא מספיק חזקות</h3>
   <p><u>אוכלוסייה בגודל 100 -</u><br>
      האלגוריתם הצליח להתייצב על מספר מסויים, אבל רק 1 מתוך 19 נסיונות הגיע לערך המינימלי – כאן הבנו שזו אוכלוסhיה שגם במספר ריצות גבוה יותר לא תניב לנו פתרונות מספיק אופטימליים ולכן הורדנו אותה מהבדיקות</p>
   
   <p><u>אוכלוסייה בגודל 250 - </u><br>
      השווינו בין הציונים של זוגות הפרמטרים בכל הריצות עבור אוכלוסייה בגודל 250, 400, 500 – הציונים שקיבלנו היו נמוכים משמעותית מהציונים של זוגות הפרמטרים עבור אוכלוסיות בגודל 400, 500.</p>
<div align="center">
   <img alt="250-400-500" src="https://github.com/YardenBoumendil/EvolutionaryOptimization/assets/96023071/4f12793c-5e8a-4c06-9e20-d437e9046fd2">    
   <img alt="400-500" src="https://github.com/YardenBoumendil/EvolutionaryOptimization/assets/96023071/51226ed9-e9a3-4701-b147-60e33a39d894">
</div>

   <p>ניתן לראות שבחלק מהמקרים יש הבדל של עשרה אחוזים בציון של זוג פרמטרים ולכן התייחסנו לאוכלוסייה בגודל 250 כאוכלוסייה לא מספיק חזקה.</p>

   <h3>אוכלוסיות חזקות</h3>
   <p>אחרי שהבנו שניתן להגיע לציונים טובים באוכלוסיות מגודל 400 ו-500 בחנו כל אחת מהן בנפרד.</p>
   <div align="center">
      <img alt="400" src="https://github.com/YardenBoumendil/EvolutionaryOptimization/assets/96023071/696a3c4b-a1fc-4c3f-ae40-0e95164b35c1">
      <img alt="500" src="https://github.com/YardenBoumendil/EvolutionaryOptimization/assets/96023071/d2aa4500-2919-4895-a50a-b134ae49e466">
   </div>   

   <p>ההבדלים לא מאוד משמעותיים אבל ברור כי אוכלוסייה בגודל 500 מביאה את התוצאות הטובות ביותר.</p>

   <h3>מציאת הסתברות אופטימלית לביצוע מוטציה וקרוס אובר</h3>
   <div align="center">
      <img alt="400-500" src="https://github.com/YardenBoumendil/EvolutionaryOptimization/assets/96023071/e7e1648e-5875-4978-9fce-9ba41e8a9f60">
   </div>

   <p>ניתן לראות כי שלושת הזוגות שקיבלו את הציונים הטובים ביותר הם (0.15,0.15), (0.35,0.15), (0.5,0.15).<br>
   בחרנו את (0.15,0.15) מכיוון שגם באוכלוסיות החלשות יותר זוג פרמטרים זה הביא את התוצאות הטובות ביותר (בריצה היחידה באוכלוסייה מגודל 100 הוא הזוג היחיד שהביא תוצאה נכונה, באוכלוסייה מגודל 250 עבור 150 דורות, הצליח להביא את התוצאה הנכונה ב-18 מתוך 20 ריצות).</p>

   <h3>מספר דורות אופטימלי</h3>
   <p>100 דורות לעומת 150 דורות<br>
   באוכלוסייה וקרוס אובר הכי חזקים (500 ושני ה-100) – הכל התכנס לפני ה-100<br>
   אבל בציון היותר נמוך 1 לא עבר, ועבור 400 גם בשלושת הכי חזקים אנחנו מקבלים כבר בערך 2 ריצות עם תוצאות טובות שמתכנסות אחרי.</p>

   <h2>מסקנות</h2>
   <ul>
   	<li>ניתן להגיע לפתרונות אופטימליים לבעיה בשימוש באלגוריתמים אבולוציוינים</li>
   	<li>גודל אוכלוסייה קטן מתכנס לנקודה מסויימת ולא מצליח לרדת ממנה לכיוון תוצאה חיובית</li>
   	<li>מוטציה וקרוס אובר נכונים יכולים להביא לתוצאות מעולות גם כשגודל האוכלוסייה לא הגדול ביותר.</li>
      <li>הפרמטרים הנבחרים הגיעו לאחוזי הצלחה דומים גם כאשר גדל טווח הערכים השונים עבור האוכלוסייה</li>
   </ul>

   <h2>הוראות הרצה</h2>
   <ul>
   	<li>הורידו את התיקייה, ופתחו command prompt בתקייה המכילה את כל הקבצים.</li>
   	<li>התקינו את החבילות הנדרשות: pip install -r requirements.txt</li>
   </ul>

   <h2>מקורות</h2>
   <p><a href="https://www.youtube.com/watch?v=XPx-a6MVne8">https://www.youtube.com/watch?v=XPx-a6MVne8</a></p>
